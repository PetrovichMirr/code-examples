Основные классы
===============

**Создание экземпляров классов, зависимости**

Для уменьшения взаимных зависимостей между основными классами приложения
применена следующая схема.

В директории `app/Contracts` определены интерфейсы основных классов приложения.
В файле конфигурации `app/config.php` задаётся соответствие между интерфейсами
и классами, реализующими эти интерфейсы. Помимо этого, в конфигурации
определяется возможное количество создаваемых экземпляров класса: 
один (одиночка) или сколько угодно, например класс `\App\Core\Kernel` реализует
интерфейс `\App\Contracts\Kernel`, экземпляр этого класса может 
быть создан только один раз:

    \App\Contracts\Kernel::class => [
        'implements' => \App\Core\Kernel::class,
        'singleton' => true,
    ],

Экземпляры основных классов приложения создаются с помощью статического 
метода `make` класса `\App\Core\Factory`. В качестве параметра этот метод 
принимает имя интерфейса, выполняет в файле конфигурации `app/config.php`
поиск класса, реализующего заданный интерфейс и создаёт экземпляр этого класса.
Если конфигурацией определено, что объект класса может быть создан только 
один раз (`'singleton' => true`) и этот объект был уже создан,
возвращается ранее созданный экземпляр.

Объекты - одиночки удобны, если логика приложения не предполагает наличие 
нескольких экземпляров каких-либо классов, также одиночки
могут использоваться для хранения каких-либо данных 
на протяжении всего жизненого цикла скрипта. Например, объект - одиночка
класса `\App\Core\Request` хранит информацию о входном запросе (запрашиваемый адрес 
страницы, имя метода, параметры запроса и т.п.), создание нескольких экземпляров
этого класса не имеет особого смысла.

Для удобства обращения к экземплярам основных классов приложения, в файле
`app/Core/helpers.php`, определены функции быстрого доступа, например
функция `request()` создаст или вернет ранее созданный экземпляр 
класса `\App\Core\Request`:

    if (!function_exists('request')) {

        /**
         * Возвращает экземпляр класса запроса (request)
         *
         * @return mixed
         */
        function request()
        {
            return Factory::make(\App\Contracts\Request::class);
        }

    }

Эти функции определены в глобальной области видимости и могут быть 
вызваны из любого места скрипта.


**Описание основных классов**

***Класс ядра `\App\Core\Kernel`*** был описан в разделе ***[Архитектура приложения -> Жизненный цикл запроса](/docs/architecture)***.

***Класс `\App\Core\Request`*** отвечает за обработку и 
хранение данных входящего HTTP-запроса.
Для выполнения этой обработки необходимо вызвать метод
`\App\Core\Request::handle()`:

    $request = request();
    $request->handle();

После этого в экземпляре класса будут доступны данные запроса. К примеру,
так можно получить URI запроса из любого места скрипта:

    $uriPath = request()->getUriPath();

***Класс `\App\Core\Route`*** отвечает за маршрутизацию (роутинг).

Для задания маршрутов используются функции:

- `\App\Core\Route::get($pattern, $action)` - маршрут для GET-запроса;
- `\App\Core\Route::post($pattern, $action)` - маршрут для POST-запроса.

Параметр `$pattern` - шаблон пути, 
`$action` - обработчик запроса, представляет собой функцию обратного вызова (callback-функцию).

Поддерживаются два типа шаблонов пути: обычные и с динамическим параметром.  
Форматы шаблона пути: `path` (обычный), `path/{}` (с динамическим параметром), где:  
- `path` - любой допустимый uri-путь, например `qwerty/asdf`;  
- `{}` - динамическая часть шаблона.
Например, шаблону пути с динамическим параметром `qwerty/asdf/{}` будут
сооветствовать запросы страниц с адресами `qwerty/asdf/123`, `qwerty/asdf/zxcv` и т.д.
Обычный шаблон пути для корневой (главной) страницы: `/`
Динамический шаблон пути для корневой (главной) страницы: `{}`.
Динамический параметр должен находится в конце шаблона,
например, шаблон `qwerty/{}/asdf/` не будет работать.

Маршруты задаются в файле `app/routes.php`.
Пример задания маршрута для главной страницы:

    route()->get('/', [
        new \App\Controllers\TaskController(),
        'index',
    ]);

Пример задания маршрута для страницы просмотра задачи:

    route()->get('tasks/{}', [
        new \App\Controllers\TaskController(),
        'show',
    ]);

***Класс `\App\Core\InputChain`*** осуществляет проверку 
корректности (валидацию) и
фильтрацию значений, например значений входных параметров.
Обработка данных выполняется согласно заданной последовательности (цепочки)
фильтров и правил валидации.
Если на каком-то этапе проверки возникла ошибка,
проверка прекращается и возвращается описание ошибки.

Перечень допустимых правил и фильтров задан константами интерфейса
`\App\Contracts\InputChain`.
Например, константа `\App\Contracts\InputChain::RULE_EMAIL`
задаёт проверку на валидность адреса электронной почты.

Пример функции, осуществляющей фильтрацию и проверку 
первичного ключа (ID) модели:

    use App\Contracts\InputChain;

    /**
     * Проверка на корректность ID модели.
     *
     * @param int $inputId Первичный ключ (ID) модели из входного запроса
     *
     * @return int ID модели.
     */
    private function inputChainID($inputId)
    {
        // Цепочка обработки входных данных (ID)
        $inputChain = inputChain()
                ->setChain([InputChain::FILTER_TRIM,
                    InputChain::RULE_NOT_EMPTY,
                    InputChain::RULE_INT])
                ->setData($inputId);
        // Проверка корректности ID
        if ($inputChain->handle() !== true) {
            response()->error(404);
        }
        return $inputChain->getData();
    }

В этой функции задана следующая цепочка фильтров и правил:

- `InputChain::FILTER_TRIM` - удаляем начальные и конечные пробельные символы
- `InputChain::RULE_NOT_EMPTY` - значение не должно быть пустым
- `InputChain::RULE_INT` - значение должно быть целым числом.

Проверка значений проходит в три этапа:

- задание цепочки с помощью метода `\App\Core\InputChain::setChain($chain)`
- установка проверяемого значения с помощью метода `\App\Core\InputChain::setData($value)`
- выполнение проверки с помощью метода `\App\Core\InputChain::handle()`.
Если проверка прошла успешно метод возвратит значение true, иначе - сообщение об ошибке.

В случае успешной проверки проверенное (и, возможно, обработанное)
значение может быть получено с помощью метода `\App\Core\InputChain::getData()`.

***Класс `\App\Core\DB`*** отвечает за работу с базой данных.
Обычная схема работы класса выглядит так:
конструирование запроса, выполнение этого запроса, 
получение результатов выполненного запроса.

Пример функции, возвращающей значение записи по первичному ключу:

    /**
     * Возвращает запись по первичному ключу.
     * Если запись не найдена, возвращает null
     *
     * @param int $primaryKeyValue Значение первичного ключа записи
     *
     * @return mixed|null Данные записи или null, если запись не найдена
     */
    public function find($primaryKeyValue)
    {
        $where = "{$this->getPrimaryKeyName()} = {$primaryKeyValue}";
        $data = $this->select()->where($where)->execute()->fetch();
        return empty($data) ? null : $data;
    }

Методы класса `\App\Core\DB` для конструирования запроса
в общем аналогичны соответствующим SQL-командам
(select, update, where, groupBy, orderBy, limit и т.п.).
Такие методы, как select, update, insert инициируют новый запрос,
последующие методы where, groupBy, orderBy, limit и т.п., - продолжают
конструирование. Содержиое текущего SQL-запроса может быть получено
с помощью метода `\App\Core\DB:getSql()`.

После того, как SQL-запрос сконструирован, он может быть выполнен
с помощью метода `\App\Core\DB:execute()`.

Результаты выполнения запроса возвращаются методами
`\App\Core\DB:fetch()` и `\App\Core\DB:fetchAll()`.
Эти методы могут принимать в качестве параметров
имя класса для возврата результатов запроса в виде
экземпляров указанного класса.
Это используется в классах моделей, где данные записи таблицы базы данных
возвращаются в виде экземпляров класса соответствующей модели.

***Класс `\App\Core\Model`*** наследует ранее рассмотренный класс
`\App\Core\DB` и предоставляет дополнительные методы для работы с моделями.

Основная задача модели - соблюдение соответствия между 
данными в таблице базы данных и данными экземпляра класса модели.
Таблица, связанная с моделью задаётся методом `\App\Core\Model::setTable($table)`
или в параметрах конструктора.

***Класс `\App\Core\View`*** содержит метод
`\App\Core\View::render($viewFile, $data = [])`.
Этот метод осуществляет ренедеринг вида 
(выводит данные в шаблон вида) и возвращает результат.
Метод принимает параметры:

- $viewFile - имя файла вида;
- $data - данные передаваемые в вид в виде ассоциативного массива.

Для вставки в шаблон передаваемых значений Метод `\App\Core\View::render()`
создаёт экземпляр класса `\App\Core\ViewTemplate\Render` и вызывает его метод
`\App\Core\ViewTemplate\Render::handle($templateContent, $data = [])`, где

- $templateContent - содержимое файла вида;
- $data - данные передаваемые в вид в виде ассоциативного массива.

***Класс `\App\Core\ViewTemplate\Render`*** по сути является шаблонизатором, 
выполняет обработку содержимого файла вида,
заменяет динамические элементы шаблона на
вычисленное значение этих элементов:

    $render = new \App\Core\ViewTemplate\Render();
    $renderData = $render->handle($viewFileContents, $data);

Принцип работы шаблонизатора:
Динамические элементы выделяются в шаблоне тегами,
например &lt;app_code&gt;...&lt;/app_code&gt;.
Между этими тегами размещается команда.
Формат команды: имя_команды(параметр_1,параметр_2, ...).
Например, для вывода php-переменной $var в нужном месте шаблона нужно прописать:
&lt;app_code&gt;out($var)&lt;/app_code&gt;.

Поиск динамических элементов осуществляется с помощью регулярных выражений.
Найденные динамические блоки анализируются, разбиваются на части:
имя команды, параметры команды. Выполнение каждой из таких найденных команд
делегируется классу `\App\Core\ViewTemplate\Command`.

***Класс `\App\Core\ViewTemplate\Command`*** выполняет команды,
заданные в динамических блоках шаблона (в файлах вида):

    $commandOut = \App\Core\ViewTemplate\Command::run($commandName, $params, $viewData);

Здесь:

- $commandName - Имя команды шаблона;
- $params - Параметры команды шаблона;
- $viewData - Массив данных, передаваемых для вывода в 
динамических блоках шаблона.

***Класс `\App\Core\Response`*** отвечает за отправку ответа приложения:

    response()->setBody($response)->send();

Схема работы класса очень проста: устанавливается тело ответа
(содержимое для вывода страницы), затем происходит отправка 
ответа (вывод содержимого тела ответа).

Более подробные сведения о классах и их методах можно получить из
[документации API](https://api.code-examples.vs24.su).  
Эта документация автоматически сгенерирована из PHPDoc - комментариев в 
исходном коде с помощью [phpDocumentor](https://phpdoc.org).